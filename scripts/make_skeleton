#!/usr/bin/env python

import argparse
from glob import glob
from os import environ, path
import re
from string import Template
import sys

# for fixing the Makefile.RootCore
from tempfile import mkstemp
from shutil import move
from os import remove, close

templates = {'plot': {'header': 'ObjectPlots.h', 'source': 'ObjectPlots.cxx'},
             'hist': {'header': 'ObjectHists.h', 'source': 'ObjectHists.cxx'}}

def get_rc_wd():
  return path.dirname(environ['ROOTCOREBIN'])

def get_script_wd():
  return path.dirname(path.realpath(__file__))

def get_rc_packages():
  rc_wd = get_rc_wd()
  p = re.compile(r'{0}/(\w+)/cmt/Makefile.RootCore'.format(rc_wd))
  return [p.match(package).groups()[0] for package in glob('{0}/*/cmt/Makefile.RootCore'.format(rc_wd))]

def parse_template(filename, **kwargs):
  return Template( open(filename).read() ).substitute(**kwargs)

# http://code.activestate.com/recipes/577058/
def query_yes_no(question, default="yes"):
  """Ask a yes/no question via raw_input() and return their answer.
  
  "question" is a string that is presented to the user.
  "default" is the presumed answer if the user just hits <Enter>.
      It must be "yes" (the default), "no" or None (meaning
      an answer is required of the user).

  The "answer" return value is one of "yes" or "no".
  """
  valid = {"yes":"yes",   "y":"yes",  "ye":"yes",
           "no":"no",     "n":"no"}
  if default == None:
    prompt = " [y/n] "
  elif default == "yes":
    prompt = " [Y/n] "
  elif default == "no":
    prompt = " [y/N] "
  else:
    raise ValueError("invalid default answer: '%s'" % default)

  while 1:
    sys.stdout.write(question + prompt)
    choice = raw_input().lower()
    if default is not None and choice == '':
      return default
    elif choice in valid.keys():
      return valid[choice]
    else:
      sys.stdout.write("Please respond with 'yes' or 'no' "\
                       "(or 'y' or 'n').\n")


parser = argparse.ArgumentParser(description='Scaffolding for xAOD Analysis Helpers')
parser.add_argument('pkg',  help='what package to scaffold into, e.g. xAODAnaHelpers',  choices=get_rc_packages())
parser.add_argument('name',     help='the name of the file & class, e.g. Jet')
parser.add_argument('type',     help='what kind of file to scaffold, e.g. plots',           choices=templates.keys())
parser.add_argument('obj',   help='what kind of object to use, e.g. Jet, Electron, etc...')

if __name__ == "__main__":
  args = parser.parse_args()
  template_arguments = {'name': args.name, 'package': args.pkg, 'obj': args.obj, 'obj_lc': args.obj.lower()}

  # script working directory, and rootcore working directory
  script_wd = get_script_wd()
  rc_wd = get_rc_wd()

  # build relative paths to output files, relative to package
  output_headerFile_relpath = path.join(args.pkg, args.pkg, '{0}.h'.format(args.name))
  output_sourceFile_relpath = path.join(args.pkg, 'Root', '{0}.cxx'.format(args.name))
  # build absolute paths to output files
  output_headerFile_abspath = path.join(rc_wd, output_headerFile_relpath)
  output_sourceFile_abspath = path.join(rc_wd, output_sourceFile_relpath)

  print "Files created will be in {0} at:".format(args.pkg)
  print "\t{0}".format(output_headerFile_relpath)
  print "\t{0}".format(output_sourceFile_relpath)
  if query_yes_no("Is this correct?", "no") == "no":
    sys.exit(0)

  # first, check if the file(s) exist already in the package being used
  if path.isfile(output_headerFile_abspath):
    print "Header file already exists at {0}".format(output_headerFile_relpath)
    sys.exit(1)
  elif path.isfile(output_sourceFile_abspath):
    print "Source file already exists at {0}".format(output_sourceFile_relpath)
    sys.exit(1)

  # parse the template files and replace the contents with substitution
  output_headerFile_contents = parse_template(path.join(script_wd, 'templates', templates[args.type]['header']), **template_arguments)
  output_sourceFile_contents = parse_template(path.join(script_wd, 'templates', templates[args.type]['source']), **template_arguments)

  with open(output_headerFile_abspath, 'w') as f:
    f.write(output_headerFile_contents)

  with open(output_sourceFile_abspath, 'w') as f:
    f.write(output_sourceFile_contents)

  # next, check the package dependencies
  pkg_makefile_path = path.join(rc_wd, args.pkg, 'cmt', 'Makefile.RootCore')

  # first make temp file to write the new Makefile.RootCore in case
  temp_fh, temp_abspath = mkstemp()
  temp_file = open(temp_abspath, 'w')

  # set up fixDependencies to determine what the user does
  fixDependencies = False
  # open and read line by line
  with open(pkg_makefile_path, 'r') as f:
    for line in f:
      if line.startswith('PACKAGE_DEP'):
        if not 'xAODAnaHelpers' in line:
          # ask user if we want to fix up their makefile
          print "We have determined that {0} does not list xAODAnaHelpers as a dependency.".format(args.pkg)
          fixDependencies = bool(query_yes_no("Do you want us to fix this?") == "yes")
          if fixDependencies:
            # they want us to, we'll read it in, grab all packages, add xAODAnaHelpers, and then sort
            package_deps = sorted(line.strip().split('=')[1].strip().split(' ') + ['xAODAnaHelpers'])
            # join and write to temp file
            temp_file.write('PACKAGE_DEP \t = {0}\n'.format(' '.join(package_deps)))
          else:
            temp_file.write(line)
        else:
          temp_file.write(line)
      else:
        temp_file.write(line)
  # close the temp file
  temp_file.close()
  close(temp_fh)

  # they want us to fix it up
  if fixDependencies:
    # remove original file
    remove(pkg_makefile_path)
    # move temp file
    move(temp_abspath, pkg_makefile_path)
  else:
    # remove the temp file, since we're not moving it
    remove(temp_abspath)
